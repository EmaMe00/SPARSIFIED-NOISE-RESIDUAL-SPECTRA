"""
Processing step: 2 (if you already have noise residuals, otherwise use 'denoise+fft.py' and ignore this script)

This script calculates the fft of a dataset. It should be used on the noise residuals generated by the denoiser NN SyntheticImagesAnalysis.
If you use 'denoise+fft.py' script, ignore this script.

Denoiser link: https://github.com/grip-unina/SyntheticImagesAnalysis/
"""

import os
from glob import glob
import cv2
import numpy as np
from PIL import Image
from tqdm import tqdm  # Import tqdm for progress bar

# Settings
Zhang = 1  # Set to 1 if using Zhang's denoiser
size = 222
need_resize = 1

def get_fft_and_residual(files, files_denoised, dataset_name):
    img_cv2_list = []
    print(f"Loading images for dataset {dataset_name}...")
    for file_path in tqdm(files, desc="Loading original images"):
        img_cv2 = cv2.imread(file_path)
        img_cv2 = cv2.cvtColor(img_cv2, cv2.COLOR_BGR2RGB)
        if Zhang == 1:
            img_cv2 = img_cv2[17:-17, 17:-17]
        img_cv2_list.append(img_cv2)

    img_cv2_list_denoised = []
    for file_path in tqdm(files_denoised, desc="Loading denoised images"):
        img_cv2 = cv2.imread(file_path)
        img_cv2 = cv2.cvtColor(img_cv2, cv2.COLOR_BGR2RGB)
        img_cv2_list_denoised.append(img_cv2)

    index = 100000
    img_cv2_list_denoised = img_cv2_list_denoised[:index]
    img_cv2_list = img_cv2_list[:index]
    print("Number of images considered: " + str(len(img_cv2_list)) + f" for dataset {dataset_name}")

    if need_resize == 1:
        for i in tqdm(range(len(img_cv2_list)), desc="Resizing images"):
            img_cv2_list[i] = resize_image(img_cv2_list[i], size)
            img_cv2_list_denoised[i] = resize_image(img_cv2_list_denoised[i], size)

    residuals_list = []
    for i in tqdm(range(len(img_cv2_list)), desc="Calculating residuals"):
        residuals = img_cv2_list[i] - img_cv2_list_denoised[i]
        residuals_list.append(residuals)

    list_residual = []
    list_residual_fft = []
    for elem in tqdm(residuals_list, desc="Calculating FFT of residuals"):
        result = np.mean(elem, -1)
        min_value = result.min()
        max_value = result.max()
        normalized_result = (result - min_value) / (max_value - min_value)
        list_residual.append(normalized_result)

        fft_g_resize = np.fft.fft2(result, axes=(0, 1), norm='ortho')
        fft_shifted_g_resize = np.fft.fftshift(fft_g_resize, axes=(0, 1))
        spectrum_fft = 20 * np.log(np.abs(fft_shifted_g_resize) + 1)

        min_value = spectrum_fft.min()
        max_value = spectrum_fft.max()
        normalized_result_fft = (spectrum_fft - min_value) / (max_value - min_value)
        list_residual_fft.append(normalized_result_fft)

    return img_cv2_list, list_residual, list_residual_fft

def resize_image(img, size):
    return cv2.resize(img, (size, size))

# Load image
def imread(filename):
    return np.asarray(Image.open(filename).convert('RGB')) / 256.0

# Path to the folder containing original and denoised images
input_folder = './synthbuster/'
input_folderDenoised = './synthbuster_denoised/'
output_folder_fft = './synthbuster_fft/'

# Find all images in the input folder (including subfolders)
image_files = glob(os.path.join(input_folder, '**', '*.png'), recursive=True)
image_files_denoised = glob(os.path.join(input_folderDenoised, '**', '*.png'), recursive=True)

os.makedirs(output_folder_fft, exist_ok=True)

# Use get_fft_and_residual to obtain the FFT
_, _, list_residual_fft = get_fft_and_residual(image_files, image_files_denoised, "dataset")

# Save the FFTs in the specified folder
for idx, fft_img in enumerate(tqdm(list_residual_fft, desc="Saving FFTs")):
    # Get the filename without extension
    file_name = f"{idx:06}_fft.png"
    
    # Create the subfolder structure for the FFT
    relative_path = os.path.relpath(image_files[idx], input_folder)
    relative_dir = os.path.dirname(relative_path)
    
    # Create the output folder for the FFT maintaining the subfolder structure
    output_dir_fft = os.path.join(output_folder_fft, relative_dir)
    os.makedirs(output_dir_fft, exist_ok=True)
    
    # Path where the FFT image will be saved
    output_path_fft = os.path.join(output_dir_fft, file_name)
    
    # Convert the FFT to PIL format
    fft_img_pil = Image.fromarray((fft_img * 256).astype(np.uint8))
    
    # Save the FFT image
    fft_img_pil.save(output_path_fft)

print("FFT calculation and saving completed.")
